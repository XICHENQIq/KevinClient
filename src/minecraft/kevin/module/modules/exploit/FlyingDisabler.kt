package kevin.module.modules.exploit

import kevin.KevinClient
import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.Render2DEvent
import kevin.event.UpdateEvent
import kevin.module.BooleanValue
import kevin.module.ListValue
import kevin.module.Module
import kevin.module.ModuleCategory
import kevin.module.modules.movement.Fly
import kevin.utils.PacketUtils
import kevin.utils.RenderUtils
import kevin.utils.render.RenderUtil
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.network.play.client.CPacketConfirmTransaction
import net.minecraft.network.play.server.SPacketChat
import net.minecraft.network.play.server.SPacketConfirmTransaction
import net.minecraft.network.play.server.SPacketPlayerAbilities
import net.minecraft.network.play.server.SPacketPlayerPosLook
import net.minecraft.world.GameType
import com.yumegod.obfuscation.Native
import java.util.concurrent.LinkedBlockingQueue
import kotlin.io.path.fileVisitor

@Native
class FlyingDisabler : Module("FlyingDisabler", "Grim new", category = ModuleCategory.EXPLOIT) {

    private val mode = ListValue("Mode", arrayOf("Sw","Bw"),"Bw")
    var cancel = false
    private val packets = LinkedBlockingQueue<SPacketConfirmTransaction>()
    var tick = 0

    override fun onEnable() {
        tick = 0
        cancel = false
    }

    override fun onDisable() {
        tick = 0
        cancel = false
        while (!packets.isEmpty()) {
            packets.take().processPacket(mc.connection!!)
        }
    }
    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (cancel) {
            tick ++
        }

        val fly = KevinClient.moduleManager[Fly::class.java] as Fly
        if (tick >= 195) {
            this.state = false
            fly.state = false
        }
        if (mc.player.isDead) {
            this.state = false
            fly.state = false
        }
    }
    @EventTarget
    fun onRender2d(event: Render2DEvent) {
        val sr = ScaledResolution(mc)
        RenderUtil.drawProcess(sr.scaledWidth / 2 - 79f,sr.scaledHeight / 2 + 100f,"Timed out",tick.toFloat(),195f, RenderUtils.skyRainbow(1,1f,1f).rgb)
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (mode.get() == "Bw") {
            if (packet is SPacketPlayerAbilities) {
                if(!packet.isAllowFlying && !cancel){
                    cancel = true
                }
            }
            if (cancel) {
                if (packet is SPacketConfirmTransaction) {
                    packets.add(packet)
                    event.cancelEvent()
                    mc.connection!!.sendPacket(CPacketConfirmTransaction())
                }
            }
        } else if (mode.get() == "Sw") {
            if (packet is SPacketPlayerAbilities) {
                if(!packet.isAllowFlying && !cancel){
                    cancel = true
                }
            }
            if (cancel) {
                if (packet is SPacketConfirmTransaction) {
                    packets.add(packet)
                    event.cancelEvent()
                    mc.connection!!.sendPacket(CPacketConfirmTransaction())
                }
            }
            if (packet is SPacketChat) {
                if (packet.chatComponent.unformattedText.contains("开始倒计时") && packet.chatComponent.unformattedText.contains("1 秒") && tick <= 180) {
                    val fly = KevinClient.moduleManager[Fly::class.java] as Fly
                    fly.state = true
                }
            }
        }
    }
}